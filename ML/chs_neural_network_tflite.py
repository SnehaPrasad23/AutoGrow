# -*- coding: utf-8 -*-
"""CHS_dataset_analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/120EIxKW-Mb2XlIe3F74TKANdS1iOv9HG
"""

import pandas as pd

path="Crop_recommendation.csv"

df=pd.read_csv(path)

df.head()

df = df[:200]

df.head()

# prompt: rename rainfall to moisture

df.rename(columns={'rainfall': 'moisture'}, inplace=True)

df['moisture'] = ((df['moisture'] - min(df['moisture']))/(max(df['moisture']) - min(df['moisture'])) * 80 ) + 15

df['moisture']

! pip install "everywhereml>=0.2.32"

# prompt: create a new dataframe using temperature, humidity , moisture columns and name it  MOISTURE

MOISTURE = df[['temperature', 'humidity', 'moisture']]

!pip install tensorflow

df.head()



import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

# Define the model
model = Sequential([
    Dense(32, activation='relu', input_shape=(2,), name='input_layer'),
    Dense(64, activation='relu', name='hidden_layer'),
    Dense(3, activation='linear', name='output_layer')
])

# Compile the model
model.compile(optimizer='adam', loss='mean_squared_error')

# Display the model summary
model.summary()

X = df[['temperature', 'humidity']]
y = df[['moisture', 'ph', 'K']]

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

model.fit(X_train, y_train, epochs=100, batch_size=32, validation_data=(X_test, y_test))

# Evaluate the model on the test set
loss = model.evaluate(X_test, y_test)
print(f"Test Loss: {loss}")

converter = tf.lite.TFLiteConverter.from_keras_model(model)
moisture_tflite_model = converter.convert()

# Save the TFLite model to a file
with open('model.tflite', 'wb') as f:
    f.write(moisture_tflite_model)

!xxd -i model.tflite > model_data.cc



# prompt: make a linear regression model for the dataframe MOISTURE for predicting the moisture column and show mse and r2 score and plot the line found after regression with red color

from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error, r2_score
from matplotlib import pyplot as plt

X_train, X_test, y_train, y_test = train_test_split(MOISTURE.drop('moisture', axis=1), MOISTURE['moisture'], test_size=0.25, random_state=42)

regressor = LinearRegression()
regressor.fit(X_train, y_train)

y_pred = regressor.predict(X_test)

mse = mean_squared_error(y_test, y_pred)

print("MSE:", mse)

print(regressor.coef_)
print(regressor.intercept_)

# prompt: create a new dataframe using temperature, humidity , rainfall and ph columns and name it  PH

PH = df[['temperature', 'humidity', 'moisture', 'ph']]

PH.head()

# prompt: make a linear regression model for the dataframe PH for predicting the ph column and show mse

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(PH.drop('ph', axis=1), PH['ph'], test_size=0.25)

from sklearn.linear_model import LinearRegression
model = LinearRegression()

model.fit(X_train, y_train)

y_pred = model.predict(X_test)

from sklearn.metrics import mean_squared_error
mse = mean_squared_error(y_test, y_pred)

print(mse)

# prompt: output the values of weights corresponding to each column in training set

model.coef_

model.intercept_

# prompt: give the equation of final regression line as well

equation = f"y = {model.coef_[0]}x + {model.intercept_}"
print(equation)

# prompt: predict ph value for a given set of temperature humidity and moisture

temp = float(input("Enter the temperature: "))
humidity = float(input("Enter the humidity: "))
moisture = float(input("Enter the moisture: "))

# Convert the moisture value to a scale of 0 to 95
moisture = ((moisture-min_moisture)/(max_moisture-min_moisture))*95

# Create a dataframe with the input values
new_df = pd.DataFrame({'temperature': [temp], 'humidity': [humidity], 'moisture': [moisture]})

# Predict the pH value
y_pred = model.predict(df)

# Print the predicted pH value
print(f"The predicted pH value is {y_pred[0]}")
print(max_moisture-min_moisture)

# prompt: create a new dataframe using temperature, humidity , rainfall , ph and N columns and name it  N

N=df[['temperature', 'humidity', 'moisture', 'ph','N']]

N.head()

# prompt: scal the N values in range 1-5

N['N']=((N['N']-min(N['N']))/(max(N['N'])-min(N['N']))*4)+1

# prompt: predict 'N' value for a given set of temperature humidity moisture and ph

X_train, X_test, y_train, y_test = train_test_split(N.drop('N', axis=1), N['N'], test_size=0.25)

model = LinearRegression()

model.fit(X_train, y_train)

y_pred = model.predict(X_test)

mse = mean_squared_error(y_test, y_pred)

print(mse)


print(model.coef_)

(model.intercept_)

# prompt: create a Pew dataframe usiPg temperature, humidity , moisture , ph aPd P columPs aPd Pame it  P

P = df[['temperature', 'humidity', 'moisture', 'ph', 'P']]

P['P']=(((P['P']-min(P['P']))/(max(P['P'])-min(P['P']))*4)+1)*0.5

P.head()

X_train, X_test, y_train, y_test = train_test_split(P.drop('P', axis=1), P['P'], test_size=0.25)

model = LinearRegression()

model.fit(X_train, y_train)

y_pred = model.predict(X_test)

mse = mean_squared_error(y_test, y_pred)

print(mse)


print(model.coef_)

(model.intercept_)

K = df[['temperature', 'humidity', 'moisture', 'ph', 'K']]

K['K']=(((K['K']-min(K['K']))/(max(K['K'])-min(K['K']))*4)+1)*1.5

K.head()

X_train, X_test, y_train, y_test = train_test_split(K.drop('K', axis=1), K['K'], test_size=0.25)

model = LinearRegression()

model.fit(X_train, y_train)

y_pred = model.predict(X_test)

mse = mean_squared_error(y_test, y_pred)

print(mse)


print(model.coef_)

(model.intercept_)

# prompt: plot a graN which shows the actual value of temperature against the actual value of N and plot the respective N prediction live as well

# Import necessary libraries
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression

# Define the data
actual_temperature = N['temperature'][:10]
actual_N = N['N'][:10]
predicted_N = model.predict(N[['temperature', 'humidity','moisture','ph']])[:10]

# Create the scatter plot of actual temperature vs actual N
plt.scatter(actual_temperature, actual_N)

# Plot the predicted N values as a line
plt.plot(actual_temperature, predicted_N, color='red')

# Add labels and title
plt.xlabel('Temperature')
plt.ylabel('N')
plt.title('Actual vs Predicted N')

# Show the plot
plt.show()

max(N['N'])